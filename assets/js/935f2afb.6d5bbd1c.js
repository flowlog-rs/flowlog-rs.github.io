"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[53],{1109:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"link","label":"Welcome","href":"/tutorial/intro","docId":"intro"},{"type":"category","label":"Getting Started","collapsible":true,"items":[{"type":"link","label":"Environment Setup","href":"/tutorial/getting-started/environment","docId":"getting-started/environment"},{"type":"link","label":"Build the Workspace","href":"/tutorial/getting-started/build","docId":"getting-started/build"},{"type":"link","label":"Architecture Overview","href":"/tutorial/getting-started/architecture","docId":"getting-started/architecture"},{"type":"link","label":"Generator CLI","href":"/tutorial/getting-started/generator-cli","docId":"getting-started/generator-cli"}],"collapsed":true},{"type":"category","label":"Tutorial","items":[{"type":"link","label":"End-to-End Example","href":"/tutorial/tutorial/end-to-end","docId":"tutorial/end-to-end"},{"type":"link","label":"Regression Harness","href":"/tutorial/tutorial/regression-harness","docId":"tutorial/regression-harness"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Language","items":[{"type":"link","label":"Language Overview","href":"/tutorial/language/overview","docId":"language/overview"},{"type":"link","label":"Current Limitations","href":"/tutorial/language/limitations","docId":"language/limitations"},{"type":"link","label":"Background Reading","href":"/tutorial/language/background","docId":"language/background"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Operations","items":[{"type":"link","label":"Contributing","href":"/tutorial/operations/contributing","docId":"operations/contributing"},{"type":"link","label":"Acknowledgements","href":"/tutorial/operations/acknowledgements","docId":"operations/acknowledgements"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Publications","items":[{"type":"link","label":"Contributors","href":"/tutorial/publications/contributors","docId":"publications/contributors"},{"type":"link","label":"Publications","href":"/tutorial/publications/","docId":"publications/publications"}],"collapsed":true,"collapsible":true}]},"docs":{"getting-started/architecture":{"id":"getting-started/architecture","title":"Architecture Overview","description":"Each crate produces an artifact consumed by the next stage: parsed ASTs feed the stratifier, stratified rules become logical plans, and the planner emits dataflow descriptions that the generator renders into Timely/Differential Rust projects.","sidebar":"tutorialSidebar"},"getting-started/build":{"id":"getting-started/build","title":"Build the Workspace","description":"Compile Everything","sidebar":"tutorialSidebar"},"getting-started/environment":{"id":"getting-started/environment","title":"Environment Setup","description":"Bootstrap Script","sidebar":"tutorialSidebar"},"getting-started/generator-cli":{"id":"getting-started/generator-cli","title":"Generator CLI","description":"Use the generator to lower FlowLog programs into Timely/Differential Cargo projects.","sidebar":"tutorialSidebar"},"intro":{"id":"intro","title":"Welcome to FlowLog","description":"FlowLog is a Datalog-inspired toolchain for building dataflow services. It compiles Datalog programs into Rust crates backed by Differential Dataflow, ingests telemetry and cloud-flow data, and plans optimized pipelines that are ready to deploy. FlowLog is built for workloads that need to keep results fresh as data changes, without giving up on performance stability or operability at scale.","sidebar":"tutorialSidebar"},"language/background":{"id":"language/background","title":"Background Reading","description":"FlowLog builds on the VLDB 2026 paper:","sidebar":"tutorialSidebar"},"language/limitations":{"id":"language/limitations","title":"Current Limitations","description":"- Aggregations must appear as the final argument of an IDB head, and every rule deriving that relation must agree on the operator. The grammar accepts average/AVG, but support is not implemented.","sidebar":"tutorialSidebar"},"language/overview":{"id":"language/overview","title":"Language Overview","description":"FlowLog accepts a Souffl\xe9-compatible Datalog dialect with recursion, negation, arithmetic, and aggregations.","sidebar":"tutorialSidebar"},"operations/acknowledgements":{"id":"operations/acknowledgements","title":"Acknowledgements","description":"FlowLog succeeds FlowLog. We appreciate the community members who validated early prototypes, especially Hangdong Zhao for architectural guidance and benchmarks.","sidebar":"tutorialSidebar"},"operations/contributing":{"id":"operations/contributing","title":"Contributing","description":"We welcome pull requests and bug reports.","sidebar":"tutorialSidebar"},"publications/contributors":{"id":"publications/contributors","title":"Contributors","description":"The contributors with their contributions are listed below:","sidebar":"tutorialSidebar"},"publications/publications":{"id":"publications/publications","title":"Publications","description":"- Hangdong Zhao, Zhenghong Yu, Yuhan Rao, Henrik Frisk, Wenchao Fan, Paraschos Koutris. FlowLog: Efficient and Extensible Datalog via Incrementality. Proceedings of VLDB 2026. [PDF]","sidebar":"tutorialSidebar"},"tutorial/end-to-end":{"id":"tutorial/end-to-end","title":"End-to-End Example","description":"The example/reach.dl program computes nodes reachable from a seed set.","sidebar":"tutorialSidebar"},"tutorial/regression-harness":{"id":"tutorial/regression-harness","title":"Regression Harness","description":"tools/check/check.sh automates dataset downloads, code generation, execution, and verification.","sidebar":"tutorialSidebar"}}}')}}]);