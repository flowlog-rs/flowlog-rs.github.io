"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[5735],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),c=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(p.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},s=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,p=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),s=c(n),m=r,h=s["".concat(p,".").concat(m)]||s[m]||d[m]||l;return n?a.createElement(h,i(i({ref:t},u),{},{components:n})):a.createElement(h,i({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=s;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var c=2;c<l;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}s.displayName="MDXCreateElement"},8038:(e,t,n)=>{n.d(t,{Z:()=>r});var a=n(7294);const r=()=>a.createElement("span",{className:"flowlog"},a.createElement("span",{className:"flow"},"Flow"),a.createElement("span",{className:"log"},"Log"))},1856:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>s,frontMatter:()=>i,metadata:()=>p,toc:()=>u});var a=n(7462),r=(n(7294),n(3905)),l=n(8038);const i={sidebar_position:3,title:"Step 2: Run it"},o=void 0,p={unversionedId:"getting-started/run-it",id:"getting-started/run-it",title:"Step 2: Run it",description:"Batch Mode",source:"@site/docs/getting-started/run-it.md",sourceDirName:"getting-started",slug:"/getting-started/run-it",permalink:"/tutorial/getting-started/run-it",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,title:"Step 2: Run it"},sidebar:"tutorialSidebar",previous:{title:"Step 1: Write a program",permalink:"/tutorial/getting-started/write-a-program"},next:{title:"End-to-End Example",permalink:"/tutorial/tutorial/end-to-end"}},c={},u=[{value:"Batch Mode",id:"batch-mode",level:2},{value:"Prepare input files",id:"prepare-input-files",level:3},{value:"Compile the program",id:"compile-the-program",level:3},{value:"Run the generated crate",id:"run-the-generated-crate",level:3},{value:"Incremental Mode",id:"incremental-mode",level:2},{value:"Compile the program",id:"compile-the-program-1",level:3},{value:"Run the generated crate",id:"run-the-generated-crate-1",level:3},{value:"Insert facts and commit",id:"insert-facts-and-commit",level:3},{value:"Remove facts and observe updates",id:"remove-facts-and-observe-updates",level:3}],d={toc:u};function s(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"batch-mode"},"Batch Mode"),(0,r.kt)("p",null,"In batch mode, the runtime loads all input facts from CSV files on disk, evaluates the program once, and then exits."),(0,r.kt)("p",null,"We continues from ",(0,r.kt)("strong",{parentName:"p"},"Step 1")," using reachability program ",(0,r.kt)("inlineCode",{parentName:"p"},"reachability.dl"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-flowlog"},'.decl Source(id: number)\n.input Source(IO="file", filename="Source.csv", delimiter=",")\n\n.decl Arc(x: number, y: number)\n.input Arc(IO="file", filename="Arc.csv", delimiter=",")\n\n.decl Reach(id: number)\n.output Reach\n\nReach(y) :- Source(y).\nReach(y) :- Reach(x), Arc(x, y).\n')),(0,r.kt)("blockquote",null,(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Source")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"Arc")," are input relations, so their facts are read from CSV files."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Reach")," is the result relation. With ",(0,r.kt)("inlineCode",{parentName:"li"},".printsize"),", FlowLog prints only the number of tuples in ",(0,r.kt)("inlineCode",{parentName:"li"},"Reach"),"."))),(0,r.kt)("h3",{id:"prepare-input-files"},"Prepare input files"),(0,r.kt)("p",null,"Create the input CSV files (one tuple per line, comma-separated for ",(0,r.kt)("inlineCode",{parentName:"p"},"Arc"),")."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csv"},"# Source.csv\n1\n\n# Arc.csv\n1,2\n2,3\n")),(0,r.kt)("p",null,"With these inputs, we could imagine the runtime should derive ",(0,r.kt)("inlineCode",{parentName:"p"},"Reach = {1,2,3}")," (node ",(0,r.kt)("inlineCode",{parentName:"p"},"3")," becomes reachable by chaining ",(0,r.kt)("inlineCode",{parentName:"p"},"1\u21922\u21923"),")."),(0,r.kt)("h3",{id:"compile-the-program"},"Compile the program"),(0,r.kt)("p",null,"We can compile this program by running"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"$ flowlog reachability.dl -o reachability -F . -D .\n")),(0,r.kt)("p",null,"This generates a Rust crate at ",(0,r.kt)("inlineCode",{parentName:"p"},"reachability/"),", note that no ",(0,r.kt)("inlineCode",{parentName:"p"},"reach.csv")," has been produced, as the program has not yet been evaluated."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"-F")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"-D")," options specify the directories for input and output files respectively. So in this case, ",(0,r.kt)("inlineCode",{parentName:"p"},"Source.csv")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Arc.csv")," is in the generated rust crate working directory ",(0,r.kt)("inlineCode",{parentName:"p"},"."),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"Reach.csv")," will be produced here also."),(0,r.kt)("p",null,"If instead ",(0,r.kt)("inlineCode",{parentName:"p"},"Source.csv")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Arc.csv")," were in a subdirectory called ",(0,r.kt)("inlineCode",{parentName:"p"},"input"),", and we wanted to have ",(0,r.kt)("inlineCode",{parentName:"p"},"Reach.csv")," in a subdirectory called ",(0,r.kt)("inlineCode",{parentName:"p"},"output"),", we could do"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"$ flowlog reachability.dl -o reachability -F ./input -D ./output\n")),(0,r.kt)("h3",{id:"run-the-generated-crate"},"Run the generated crate"),(0,r.kt)("p",null,"To evaluate our program, we have to run the compiled rust crate"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"# Enter generated rust crate \n$ cd reachability\n$ cargo run --release -- -w 4\n")),(0,r.kt)("p",null,"This compiles the generated ",(0,r.kt)(l.Z,{mdxType:"StyledFlowLog"})," workspace in release mode and executes it with four worker threads. Use fewer workers on laptops with limited cores or drop ",(0,r.kt)("inlineCode",{parentName:"p"},"--release")," for faster rebuilds while editing."),(0,r.kt)("h2",{id:"incremental-mode"},"Incremental Mode"),(0,r.kt)("p",null,"In ",(0,r.kt)("strong",{parentName:"p"},"incremental mode"),", input relations are updated at runtime through an interactive shell.\nUpdates are applied in ",(0,r.kt)("strong",{parentName:"p"},"Transactions"),": you ",(0,r.kt)("inlineCode",{parentName:"p"},"begin"),", stage updates (",(0,r.kt)("inlineCode",{parentName:"p"},"put")," / ",(0,r.kt)("inlineCode",{parentName:"p"},"file"),"), then ",(0,r.kt)("inlineCode",{parentName:"p"},"commit")," to publish them and advance logical time."),(0,r.kt)("p",null,"We continues from ",(0,r.kt)("strong",{parentName:"p"},"Step 1")," but using a slightly different reachability program ",(0,r.kt)("inlineCode",{parentName:"p"},"reachability.dl"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-flowlog"},'.decl Source(id: number)\n.input Source(IO="cmd", delimiter=",")\n\n.decl Arc(x: number, y: number)\n.input Arc(IO="cmd", delimiter=",")\n\n.decl Reach(id: number)\n.output Reach\n\nReach(y) :- Source(y).\nReach(y) :- Reach(x), Arc(x, y).\n')),(0,r.kt)("h3",{id:"compile-the-program-1"},"Compile the program"),(0,r.kt)("p",null,"We generate a Rust crate:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"$ flowlog reachability.dl -o reachability -D . --mode incremental \n")),(0,r.kt)("p",null,"In incremental mode, inputs come from the interactive shell, so ",(0,r.kt)("inlineCode",{parentName:"p"},"-F")," is not used. Outputs still go to disk, so ",(0,r.kt)("inlineCode",{parentName:"p"},"-D")," still matters for ",(0,r.kt)("inlineCode",{parentName:"p"},".output")," relations."),(0,r.kt)("h3",{id:"run-the-generated-crate-1"},"Run the generated crate"),(0,r.kt)("p",null,"Start the interactive shell by running the generated crate:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"# Enter generated rust crate\n$ cd reachability\n$ cargo run --release -- -w 4\n")),(0,r.kt)("p",null,"You should see a prompt like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-txt"},"... Dataflow assembled\nFlowLog Incremental Interactive Shell, type 'help' for commands.\n")),(0,r.kt)("h3",{id:"insert-facts-and-commit"},"Insert facts and commit"),(0,r.kt)("p",null,"We start a transaction:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-txt"},">> begin\n(txn begin)\n")),(0,r.kt)("p",null,"Insert a ",(0,r.kt)("inlineCode",{parentName:"p"},"Source")," node:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-txt"},">> put Source 1\n(queued put)\n")),(0,r.kt)("p",null,"Insert ",(0,r.kt)("inlineCode",{parentName:"p"},"Arc")," edges (note the comma-separated tuple, matching ",(0,r.kt)("inlineCode",{parentName:"p"},'delimiter=","'),"):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-txt"},">> put Arc 1,2\n(queued put)\n>> put Arc 2,3\n(queued put)\n")),(0,r.kt)("p",null,"You can also insert tuples using file interface if they are large,"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-txt"},">> file Arc Arc.csv \n")),(0,r.kt)("p",null,"We finally commit the transaction:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-txt"},">> commit\n[tuple][reach]  t=0  data=(1,)  diff=+1\n[tuple][reach]  t=0  data=(2,)  diff=+1\n[tuple][reach]  t=0  data=(3,)  diff=+1\n1.074922ms:     Committed & executed\n")),(0,r.kt)("h3",{id:"remove-facts-and-observe-updates"},"Remove facts and observe updates"),(0,r.kt)("p",null,"Incremental mode supports deletions by providing a negative multiplicity (",(0,r.kt)("inlineCode",{parentName:"p"},"diff = -1"),").\nFor example, remove the edge ",(0,r.kt)("inlineCode",{parentName:"p"},"2 -> 3"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-txt"},">> begin\n(txn begin)\n>> put Arc 2,3 -1\n(queued put)\n>> commit\n[tuple][reach]  t=1  data=(3,)  diff=-1\n723.148\xb5s:      Committed & executed\n")),(0,r.kt)("p",null,"After this commit, ",(0,r.kt)("inlineCode",{parentName:"p"},"3")," is no longer reachable from ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," (for this example graph), so ",(0,r.kt)("inlineCode",{parentName:"p"},"Reach")," is updated accordingly in the next output snapshot / size print."),(0,r.kt)("p",null,"The interactive shell offers additional commands (e.g., ",(0,r.kt)("inlineCode",{parentName:"p"},"help"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"abort"),"). We\u2019ll cover the full command reference in the following section. There also have many other useful options available to ",(0,r.kt)(l.Z,{mdxType:"StyledFlowLog"}),", so be sure to explore them too!"))}s.isMDXComponent=!0}}]);