"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[1763],{3905:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>c});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=r.createContext({}),u=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},s=function(e){var t=u(e.components);return r.createElement(p.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,p=e.parentName,s=i(e,["components","mdxType","originalType","parentName"]),d=u(n),c=a,g=d["".concat(p,".").concat(c)]||d[c]||m[c]||o;return n?r.createElement(g,l(l({ref:t},s),{},{components:n})):r.createElement(g,l({ref:t},s))}));function c(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,l=new Array(o);l[0]=d;var i={};for(var p in t)hasOwnProperty.call(t,p)&&(i[p]=t[p]);i.originalType=e,i.mdxType="string"==typeof e?e:a,l[1]=i;for(var u=2;u<o;u++)l[u]=n[u];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},8038:(e,t,n)=>{n.d(t,{Z:()=>a});var r=n(7294);const a=()=>r.createElement("span",{className:"flowlog"},r.createElement("span",{className:"flow"},"Flow"),r.createElement("span",{className:"log"},"Log"))},2691:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>i,default:()=>d,frontMatter:()=>l,metadata:()=>p,toc:()=>s});var r=n(7462),a=(n(7294),n(3905)),o=n(8038);const l={sidebar_position:2,title:"Run FlowLog"},i=void 0,p={unversionedId:"getting-started/run-flowlog",id:"getting-started/run-flowlog",title:"Run FlowLog",description:"is a compiler for executing Datalog programs. The execution mode (batch, incremental) is determined by the runtime argument --mode.",source:"@site/docs/getting-started/run-flowlog.md",sourceDirName:"getting-started",slug:"/getting-started/run-flowlog",permalink:"/tutorial/getting-started/run-flowlog",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,title:"Run FlowLog"},sidebar:"tutorialSidebar",previous:{title:"Install FlowLog",permalink:"/tutorial/getting-started/install-flowlog"},next:{title:"A Simple Example",permalink:"/tutorial/getting-started/simple-example"}},u={},s=[{value:"Input/Output",id:"inputoutput",level:2},{value:"Input relations",id:"input-relations",level:3},{value:"Batch mode",id:"batch-mode",level:4},{value:"Incremental mode",id:"incremental-mode",level:4},{value:"Output relations",id:"output-relations",level:3},{value:"Delimiters, compression",id:"delimiters-compression",level:3},{value:"Printing relation sizes",id:"printing-relation-sizes",level:3},{value:"Profiling (unsuported for now)",id:"profiling-unsuported-for-now",level:2},{value:"Parallel execution",id:"parallel-execution",level:2},{value:"Verbose compiler output",id:"verbose-compiler-output",level:2}],m={toc:s};function d(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,(0,a.kt)(o.Z,{mdxType:"StyledFlowLog"})," is a compiler for executing Datalog programs. The execution mode (batch, incremental) is determined by the runtime argument `--mode`."),(0,a.kt)("h2",{id:"inputoutput"},"Input/Output"),(0,a.kt)("p",null,(0,a.kt)(o.Z,{mdxType:"StyledFlowLog"})," supports file-based I/O so you can separate Datalog programs from their data. Input files correspond to the extensional database (",(0,a.kt)("strong",null,"EDB"),") while output files correspond to the intensional database (",(0,a.kt)("strong",null,"IDB"),") in Datalog terminology."),(0,a.kt)("h3",{id:"input-relations"},"Input relations"),(0,a.kt)("p",null,"A relation becomes an input relation when you add ",(0,a.kt)("inlineCode",{parentName:"p"},".input")," to its declaration:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-flowlog"},".decl my_relation(a:number, b:number)\n.input my_relation\n")),(0,a.kt)("h4",{id:"batch-mode"},"Batch mode"),(0,a.kt)("p",null,"In ",(0,a.kt)("strong",{parentName:"p"},"batch")," mode, ",(0,a.kt)(o.Z,{mdxType:"StyledFlowLog"})," loads all input facts from disk before executing the program."),(0,a.kt)("p",null,"By default, ",(0,a.kt)(o.Z,{mdxType:"StyledFlowLog"})," searches for input facts in the directory specified by ",(0,a.kt)("inlineCode",{parentName:"p"},"-F <fact-dir>"),". If ",(0,a.kt)("inlineCode",{parentName:"p"},"-F")," is not provided, it assumes the fact files are in the current directory. The default filename is ",(0,a.kt)("inlineCode",{parentName:"p"},"<relation_name>.csv"),", so the example above expects ",(0,a.kt)("inlineCode",{parentName:"p"},"my_relation.csv")," in either the current directory or ",(0,a.kt)("inlineCode",{parentName:"p"},"<fact-dir>"),"."),(0,a.kt)("p",null,"If you need precise control over the filename, specify it explicitly:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-flowlog"},'.decl my_relation(a:number, b:number)\n.input my_relation(filename="my_relation_data.csv")\n')),(0,a.kt)("h4",{id:"incremental-mode"},"Incremental mode"),(0,a.kt)("p",null,"In ",(0,a.kt)("strong",{parentName:"p"},"incremental")," mode, input relations are updated at runtime through an interactive command loop (instead of being loaded from ",(0,a.kt)("inlineCode",{parentName:"p"},"-F"),"). You can push tuple-level or file-based updates, then ",(0,a.kt)("inlineCode",{parentName:"p"},"commit")," to apply them."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"Usage:\n  cmd | begin\n  put  <rel> <tuple> [diff]\n  file <rel> <path>  [diff]\n  commit | done\n  abort | rollback\n  help | h | ?\n  quit | exit | q\n\nCommands:\n  cmd, begin\n      Begin a transaction.\n\n  put <rel> <tuple> [diff]\n      Apply an update to relation <rel>.\n      <tuple> is comma-separated (e.g., 1,2 or 7).\n      [diff] defaults to +1.\n\n      Nullary relations (arity 0):\n        Use boolean tuples to toggle presence:\n          put <rel> True    # insert (diff = +1)\n          put <rel> False   # delete (diff = -1)\n        For nullary relations, any [diff] you provide is ignored.\n\n  file <rel> <path> [diff]\n      Apply updates from CSV file <path> to relation <rel>.\n      [diff] defaults to +1.\n\n      Nullary relations (arity 0):\n        File ingestion is not supported; use `put <rel> True|False`.\n\n  commit, done\n      Commit the transaction and advance time.\n\n  abort, rollback\n      Abort the transaction (discard staged updates).\n\n  help, h, ?\n      Show this help text.\n\n  quit, exit, q\n      Exit.\n")),(0,a.kt)("p",null,"Notes:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"put <rel> <tuple> [diff]")," applies a single-tuple update."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"file <rel> <path> [diff]")," applies updates from a CSV at an explicit filesystem path (so ",(0,a.kt)("inlineCode",{parentName:"li"},"-F")," is not used here)."),(0,a.kt)("li",{parentName:"ul"},"The optional ",(0,a.kt)("inlineCode",{parentName:"li"},"diff")," is a signed multiplicity (e.g., ",(0,a.kt)("inlineCode",{parentName:"li"},"+1"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"-1"),"). If omitted, it defaults to ",(0,a.kt)("inlineCode",{parentName:"li"},"+1"),".")),(0,a.kt)("p",null,"To select the mode when running the generated Rust crate, pass ",(0,a.kt)("inlineCode",{parentName:"p"},"--mode")," to the compiled binary:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"# Batch: load inputs from -F, write outputs to -D\n$ cargo run --release -- --mode batch -w 4 -F ./input -D ./output\n\n# Incremental: interactively update inputs; outputs still go to -D\n$ cargo run --release -- --mode incremental -w 4 -D ./output\n")),(0,a.kt)("h3",{id:"output-relations"},"Output relations"),(0,a.kt)("p",null,"You can mark relations for output with ",(0,a.kt)("inlineCode",{parentName:"p"},".output"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-flowlog"},".decl result(a:number, b:number, c:number)\n.output result\n")),(0,a.kt)("p",null,"In both ",(0,a.kt)("strong",{parentName:"p"},"batch")," and ",(0,a.kt)("strong",{parentName:"p"},"incremental")," modes, ",(0,a.kt)(o.Z,{mdxType:"StyledFlowLog"})," writes outputs to the current directory by default. You can set a default output directory with ",(0,a.kt)("inlineCode",{parentName:"p"},"-D <output-dir>"),", or write to standard output with ",(0,a.kt)("inlineCode",{parentName:"p"},"-D -"),". With default naming, the example above is written under the name ",(0,a.kt)("inlineCode",{parentName:"p"},"result.csv")," in the chosen output directory."),(0,a.kt)("p",null,"As with input, you can specify a custom output file:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-flowlog"},'.decl result(a:number, b:number, c:number)\n.output result(filename="result.csv")\n')),(0,a.kt)("p",null,"In ",(0,a.kt)("strong",{parentName:"p"},"incremental")," mode, outputs are emitted as the computation advances, so ",(0,a.kt)(o.Z,{mdxType:"StyledFlowLog"})," appends a timestamp suffix to the output filename to avoid overwriting previous snapshots (for example, ",(0,a.kt)("inlineCode",{parentName:"p"},"result_<timestamp>.csv"),")."),(0,a.kt)("h3",{id:"delimiters-compression"},"Delimiters, compression"),(0,a.kt)("p",null,"Both input and output support a custom ",(0,a.kt)("inlineCode",{parentName:"p"},"delimiter")," and can choose whether the data is compressed. For example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-flowlog"},'.decl result(a:number, b:number, c:number)\n.output result(filename="<path to output file>", delimiter="|", compress=true)\n')),(0,a.kt)("p",null,"This writes columns separated by ",(0,a.kt)("inlineCode",{parentName:"p"},"|")," and compresses the output using gzip (TODO: unsupported feature)."),(0,a.kt)("h3",{id:"printing-relation-sizes"},"Printing relation sizes"),(0,a.kt)("p",null,"If you use ",(0,a.kt)("inlineCode",{parentName:"p"},".printsize"),", ",(0,a.kt)(o.Z,{mdxType:"StyledFlowLog"})," prints the number of tuples of a relation to standard output instead of writing the relation to a file:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-flowlog"},".decl result(a:number, b:number, c:number)\n.printsize result\n")),(0,a.kt)("h2",{id:"profiling-unsuported-for-now"},"Profiling (unsuported for now)"),(0,a.kt)("p",null,"As a side-effect of execution, a profiling log can be generated. You can visualize this log with ",(0,a.kt)("inlineCode",{parentName:"p"},"flowlogprof")," (see the profiler section for details). Profiling is enabled by passing ",(0,a.kt)("inlineCode",{parentName:"p"},"-p <log-file>")," when running the compiler, and it works in both batch and incremental modes."),(0,a.kt)("h2",{id:"parallel-execution"},"Parallel execution"),(0,a.kt)("p",null,"All execution modes of ",(0,a.kt)(o.Z,{mdxType:"StyledFlowLog"})," support parallel evaluation ",(0,a.kt)("strong",{parentName:"p"},"at runtime"),". Parallelism is controlled when running the ",(0,a.kt)("strong",{parentName:"p"},"compiled")," Rust binary (the generated crate), not when invoking the ",(0,a.kt)(o.Z,{mdxType:"StyledFlowLog"})," compiler."),(0,a.kt)("p",null,"Use ",(0,a.kt)("inlineCode",{parentName:"p"},"-w <num>")," to choose the number of worker threads:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"# Run the compiled crate with 4 workers\n$ cargo run --release -- -w 4\n")),(0,a.kt)("h2",{id:"verbose-compiler-output"},"Verbose compiler output"),(0,a.kt)("p",null,"The ",(0,a.kt)(o.Z,{mdxType:"StyledFlowLog"})," compiler is itself a Rust program, so you can enable more verbose ",(0,a.kt)("strong",{parentName:"p"},"compiler")," logs by setting ",(0,a.kt)("inlineCode",{parentName:"p"},"RUST_LOG")," when you run ",(0,a.kt)(o.Z,{mdxType:"StyledFlowLog"}),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"$ RUST_LOG=debug flowlog examples/example.dl -o example_flowlog -F ./input -D ./output\n")),(0,a.kt)("p",null,"Valid levels are typically ",(0,a.kt)("inlineCode",{parentName:"p"},"trace"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"debug"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"info"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"warn"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"error"),"."),(0,a.kt)("p",null,"Note: ",(0,a.kt)("inlineCode",{parentName:"p"},"RUST_LOG")," here controls the ",(0,a.kt)("strong",{parentName:"p"},"compiler's")," logging (i.e., the ",(0,a.kt)("inlineCode",{parentName:"p"},"flowlog")," command). It is separate from runtime flags like ",(0,a.kt)("inlineCode",{parentName:"p"},"-w")," / ",(0,a.kt)("inlineCode",{parentName:"p"},"-j"),", which control how the ",(0,a.kt)("strong",{parentName:"p"},"compiled binary")," executes your program."),(0,a.kt)("p",null,"More informations about verbose compiler output is described in the developer documentations."))}d.isMDXComponent=!0}}]);