"use strict";(globalThis.webpackChunk=globalThis.webpackChunk||[]).push([[2876],{5680:(e,t,n)=>{n.d(t,{xA:()=>s,yg:()=>c});var r=n(6540);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach(function(t){a(e,t,n[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))})}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=r.createContext({}),u=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},s=function(e){var t=u(e.components);return r.createElement(p.Provider,{value:t},e.children)},m="mdxType",g={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef(function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,p=e.parentName,s=i(e,["components","mdxType","originalType","parentName"]),m=u(n),d=a,c=m["".concat(p,".").concat(d)]||m[d]||g[d]||o;return n?r.createElement(c,l(l({ref:t},s),{},{components:n})):r.createElement(c,l({ref:t},s))});function c(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,l=new Array(o);l[0]=d;var i={};for(var p in t)hasOwnProperty.call(t,p)&&(i[p]=t[p]);i.originalType=e,i[m]="string"==typeof e?e:a,l[1]=i;for(var u=2;u<o;u++)l[u]=n[u];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},6351:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>i,default:()=>d,frontMatter:()=>l,metadata:()=>p,toc:()=>s});var r=n(8168),a=(n(6540),n(5680)),o=n(9067);const l={sidebar_position:3,title:"Run FlowLog"},i=void 0,p={unversionedId:"getting-started/run-flowlog",id:"getting-started/run-flowlog",title:"Run FlowLog",description:"is a compiler for executing Datalog programs. The execution mode (batch, incremental, etc.) is determined by the runtime arguments when you execute the generated program.",source:"@site/docs/getting-started/run-flowlog.md",sourceDirName:"getting-started",slug:"/getting-started/run-flowlog",permalink:"/tutorial/getting-started/run-flowlog",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,title:"Run FlowLog"},sidebar:"tutorialSidebar",previous:{title:"A Simple Example",permalink:"/tutorial/getting-started/simple-example"},next:{title:"Examples",permalink:"/tutorial/getting-started/examples"}},u={},s=[{value:"Input/Output",id:"inputoutput",level:2},{value:"Input relations",id:"input-relations",level:3},{value:"Batch mode",id:"batch-mode",level:4},{value:"Incremental mode",id:"incremental-mode",level:4},{value:"Output relations",id:"output-relations",level:3},{value:"Delimiters, compression",id:"delimiters-compression",level:3},{value:"Printing relation sizes",id:"printing-relation-sizes",level:3},{value:"Profiling (unsuported for now)",id:"profiling-unsuported-for-now",level:2},{value:"Parallel execution",id:"parallel-execution",level:2},{value:"Verbose compiler output",id:"verbose-compiler-output",level:2}],m={toc:s},g="wrapper";function d(e){let{components:t,...n}=e;return(0,a.yg)(g,(0,r.A)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,a.yg)("p",null,(0,a.yg)(o.A,{mdxType:"StyledFlowLog"})," is a compiler for executing Datalog programs. The execution mode (batch, incremental, etc.) is determined by the runtime arguments when you execute the generated program."),(0,a.yg)("h2",{id:"inputoutput"},"Input/Output"),(0,a.yg)("p",null,(0,a.yg)(o.A,{mdxType:"StyledFlowLog"})," supports file-based I/O so you can separate Datalog programs from their data. Input files correspond to the extensional database (",(0,a.yg)("strong",null,"EDB"),") while output files correspond to the intensional database (",(0,a.yg)("strong",null,"IDB"),") in Datalog terminology."),(0,a.yg)("h3",{id:"input-relations"},"Input relations"),(0,a.yg)("p",null,"A relation becomes an input relation when you add ",(0,a.yg)("inlineCode",{parentName:"p"},".input")," to its declaration:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-flowlog"},".decl my_relation(a:number, b:number)\n.input my_relation\n")),(0,a.yg)("h4",{id:"batch-mode"},"Batch mode"),(0,a.yg)("p",null,"In ",(0,a.yg)("strong",{parentName:"p"},"batch")," mode, ",(0,a.yg)(o.A,{mdxType:"StyledFlowLog"})," loads all input facts from disk before executing the program."),(0,a.yg)("p",null,"By default, ",(0,a.yg)(o.A,{mdxType:"StyledFlowLog"})," searches for input facts in the directory specified by ",(0,a.yg)("inlineCode",{parentName:"p"},"-F <fact-dir>"),". If ",(0,a.yg)("inlineCode",{parentName:"p"},"-F")," is not provided, it assumes the fact files are in the current directory. The default filename is ",(0,a.yg)("inlineCode",{parentName:"p"},"<relation_name>.csv"),", so the example above expects ",(0,a.yg)("inlineCode",{parentName:"p"},"my_relation.csv")," in either the current directory or ",(0,a.yg)("inlineCode",{parentName:"p"},"<fact-dir>"),"."),(0,a.yg)("p",null,"If you need precise control over the filename, specify it explicitly:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-flowlog"},'.decl my_relation(a:number, b:number)\n.input my_relation(filename="my_relation_data.csv")\n')),(0,a.yg)("h4",{id:"incremental-mode"},"Incremental mode"),(0,a.yg)("p",null,"In ",(0,a.yg)("strong",{parentName:"p"},"incremental")," mode, input relations are updated at runtime through an interactive command loop (instead of being loaded from ",(0,a.yg)("inlineCode",{parentName:"p"},"-F"),"). You can push tuple-level or file-based updates, then ",(0,a.yg)("inlineCode",{parentName:"p"},"commit")," to apply them."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-text"},"Commands:\n  cmd | begin\n  put  <rel> <tuple> [diff]\n  file <rel> <path>  [diff]\n  commit | done\n  abort | rollback\n  quit | exit | q\n  help | h | ?\n\nExamples:\n  cmd\n  put source 7\n  put arc 1,2 +1\n  put arc 1,2 -1\n  file source /tmp/Source.csv +1\n  file arc    /tmp/Arc.csv    -1\n  commit\n")),(0,a.yg)("p",null,"Notes:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"put <rel> <tuple> [diff]")," applies a single-tuple update."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"file <rel> <path> [diff]")," applies updates from a CSV at an explicit filesystem path (so ",(0,a.yg)("inlineCode",{parentName:"li"},"-F")," is not used here)."),(0,a.yg)("li",{parentName:"ul"},"The optional ",(0,a.yg)("inlineCode",{parentName:"li"},"diff")," is a signed multiplicity (e.g., ",(0,a.yg)("inlineCode",{parentName:"li"},"+1"),", ",(0,a.yg)("inlineCode",{parentName:"li"},"-1"),"). If omitted, it defaults to ",(0,a.yg)("inlineCode",{parentName:"li"},"+1"),".")),(0,a.yg)("p",null,"To select the mode when running the generated Rust crate, pass ",(0,a.yg)("inlineCode",{parentName:"p"},"--mode")," to the compiled binary:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-bash"},"# Batch: load inputs from -F, write outputs to -D\n$ cargo run --release -- --mode batch -w 4 -F ./input -D ./output\n\n# Incremental: interactively update inputs; outputs still go to -D\n$ cargo run --release -- --mode incremental -w 4 -D ./output\n")),(0,a.yg)("h3",{id:"output-relations"},"Output relations"),(0,a.yg)("p",null,"You can mark relations for output with ",(0,a.yg)("inlineCode",{parentName:"p"},".output"),":"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-flowlog"},".decl result(a:number, b:number, c:number)\n.output result\n")),(0,a.yg)("p",null,"In both ",(0,a.yg)("strong",{parentName:"p"},"batch")," and ",(0,a.yg)("strong",{parentName:"p"},"incremental")," modes, ",(0,a.yg)(o.A,{mdxType:"StyledFlowLog"})," writes outputs to the current directory by default. You can set a default output directory with ",(0,a.yg)("inlineCode",{parentName:"p"},"-D <output-dir>"),", or write to standard output with ",(0,a.yg)("inlineCode",{parentName:"p"},"-D -"),". With default naming, the example above is written under the name ",(0,a.yg)("inlineCode",{parentName:"p"},"result.csv")," in the chosen output directory."),(0,a.yg)("p",null,"As with input, you can specify a custom output file:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-flowlog"},'.decl result(a:number, b:number, c:number)\n.output result(filename="result.csv")\n')),(0,a.yg)("p",null,"In ",(0,a.yg)("strong",{parentName:"p"},"incremental")," mode, outputs are emitted as the computation advances, so ",(0,a.yg)(o.A,{mdxType:"StyledFlowLog"})," appends a timestamp suffix to the output filename to avoid overwriting previous snapshots (for example, ",(0,a.yg)("inlineCode",{parentName:"p"},"result_<timestamp>.csv"),")."),(0,a.yg)("h3",{id:"delimiters-compression"},"Delimiters, compression"),(0,a.yg)("p",null,"Both input and output support a custom ",(0,a.yg)("inlineCode",{parentName:"p"},"delimiter")," and can choose whether the data is compressed. For example:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-flowlog"},'.decl result(a:number, b:number, c:number)\n.output result(filename="<path to output file>", delimiter="|", compress=true)\n')),(0,a.yg)("p",null,"This writes columns separated by ",(0,a.yg)("inlineCode",{parentName:"p"},"|")," and compresses the output using gzip (TODO: unsupported feature)."),(0,a.yg)("h3",{id:"printing-relation-sizes"},"Printing relation sizes"),(0,a.yg)("p",null,"If you use ",(0,a.yg)("inlineCode",{parentName:"p"},".printsize"),", ",(0,a.yg)(o.A,{mdxType:"StyledFlowLog"})," prints the number of tuples of a relation to standard output instead of writing the relation to a file:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-flowlog"},".decl result(a:number, b:number, c:number)\n.printsize result\n")),(0,a.yg)("h2",{id:"profiling-unsuported-for-now"},"Profiling (unsuported for now)"),(0,a.yg)("p",null,"As a side-effect of execution, a profiling log can be generated. You can visualize this log with ",(0,a.yg)("inlineCode",{parentName:"p"},"flowlogprof")," (see the profiler section for details). Profiling is enabled by passing ",(0,a.yg)("inlineCode",{parentName:"p"},"-p <log-file>")," when running the compiler, and it works in both batch and incremental modes."),(0,a.yg)("h2",{id:"parallel-execution"},"Parallel execution"),(0,a.yg)("p",null,"All execution modes of ",(0,a.yg)(o.A,{mdxType:"StyledFlowLog"})," support parallel evaluation ",(0,a.yg)("strong",{parentName:"p"},"at runtime"),". Parallelism is controlled when running the ",(0,a.yg)("strong",{parentName:"p"},"compiled")," Rust binary (the generated crate), not when invoking the ",(0,a.yg)(o.A,{mdxType:"StyledFlowLog"})," compiler."),(0,a.yg)("p",null,"Use ",(0,a.yg)("inlineCode",{parentName:"p"},"-w <num>")," to choose the number of worker threads:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-bash"},"# Run the compiled crate with 4 workers\n$ cargo run --release -- -w 4\n")),(0,a.yg)("h2",{id:"verbose-compiler-output"},"Verbose compiler output"),(0,a.yg)("p",null,"The ",(0,a.yg)(o.A,{mdxType:"StyledFlowLog"})," compiler is itself a Rust program, so you can enable more verbose ",(0,a.yg)("strong",{parentName:"p"},"compiler")," logs by setting ",(0,a.yg)("inlineCode",{parentName:"p"},"RUST_LOG")," when you run ",(0,a.yg)(o.A,{mdxType:"StyledFlowLog"}),":"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-bash"},"$ RUST_LOG=debug flowlog examples/example.dl -o example_flowlog -F ./input -D ./output\n")),(0,a.yg)("p",null,"Valid levels are typically ",(0,a.yg)("inlineCode",{parentName:"p"},"trace"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"debug"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"info"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"warn"),", and ",(0,a.yg)("inlineCode",{parentName:"p"},"error"),"."),(0,a.yg)("p",null,"Note: ",(0,a.yg)("inlineCode",{parentName:"p"},"RUST_LOG")," here controls the ",(0,a.yg)("strong",{parentName:"p"},"compiler\u2019s")," logging (i.e., the ",(0,a.yg)("inlineCode",{parentName:"p"},"flowlog")," command). It is separate from runtime flags like ",(0,a.yg)("inlineCode",{parentName:"p"},"-w")," / ",(0,a.yg)("inlineCode",{parentName:"p"},"-j"),", which control how the ",(0,a.yg)("strong",{parentName:"p"},"compiled binary")," executes your program."),(0,a.yg)("p",null,"More informations about verbose compiler output is described in the developer documentations."))}d.isMDXComponent=!0},9067:(e,t,n)=>{n.d(t,{A:()=>a});var r=n(6540);const a=()=>r.createElement("span",{className:"flowlog"},r.createElement("span",{className:"flow"},"Flow"),r.createElement("span",{className:"log"},"Log"))}}]);